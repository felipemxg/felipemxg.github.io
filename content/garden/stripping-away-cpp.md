---
title: "Stripping Away C++ - Why I Don't Use References"
date: 2022-08-03
draft: false
garden_tags: ["programming", "cpp"]
summary: " "
status: "seeding"
---

I'm a very simple and conservative guy when it comes to programming. My style of choice when coding is a very procedural, data-oriented approach. When I'm using C++, I tend to fall back to a more C-style, using the least amount of C++ features possible. There are very good reasons why I like this approach, one of which is speed, both execution time and also compile time. Arseny Kapoulkine has a very in-depth [article in his blog](https://zeux.io/2019/01/17/is-c-fast/) showing how his library _meshoptimizer_ had huge improvements in these metrics by stripping away C++ features and using a more C approach.

One of the features that I tend to not find good use is _reference_. It seems to create unnecessary complexity by making things less explicit and also can create unoptimized code. Here I will try to give some examples of this.

## A little optimization

Let's take a very simple example of a 3D vector struct:
```c++
struct Vector3 {
	float x;
	float y;
	float x;
};
```

If we want to add two vectors together, we would have to add each element of the vector. A C++ way of coding this would be to create a function that accepts two vectors by reference and returns the result:
```c++
Vector3 Vector3Add(const Vector3 &a, const Vector3 &b) {
	return Vector3 {
		a.x + b.x,
		a.y + b.y,
		a.z + b.z,
	};
}
```
This is a surprisingly common pattern you would see in a C++ codebase. A better way of doing this is by ditching the reference and using a simple pass-by-value:
```c++
Vector3 Vector3Add(Vector3 a, Vector3 b) {
	return Vector3 {
		a.x + b.x,
		a.y + b.y,
		a.z + b.z,
	};
}
```
What is the problem with this approach?

Well... Let's look at the assembly generated. Compiling with clang 14.0.0, with -O3 -march=haswell so we can enable AVX2 instructions, this is the result generated by the first example:
```nasm
Vector3Add(Vector3 const&, Vector3 const&):
	vmovsd  xmm0, qword  ptr [rdi]
	vmovsd  xmm1, qword  ptr [rsi]
	vaddps  xmm0, xmm0, xmm1
	vmovss  xmm1, dword  ptr [rdi + 8]
	vaddss  xmm1, xmm1, dword  ptr [rsi + 8]
	ret
```
At first glance, nothing is wrong with the output. Everything is happening as it should be. But what about the other second example, passing the arguments by value? This is what we get:
```nasm
Vector3Add(Vector3, Vector3):
	vaddps  xmm0, xmm0, xmm2
	vaddss  xmm1, xmm1, xmm3
	ret
```
See the difference? Because we are passing the arguments as pure values, the compiler can optimize it by storing it in the registers and doesn't need to dereference the pointers. You gain a little boost in performance without doing any fancy optimization tricks. The same thing happens in ARM64 architecture (compiled with armv8-a clang version 10.0.1 with flags -O3 -march=armv8-a+simd):
```nasm
Vector3Add(Vector3 const&, Vector3 const&):
	ldr  d1, [x1]
	ldr  s2, [x0, #8]
	ldr  s3, [x1, #8]
	fadd  v0.2s, v0.2s, v1.2s
	mov  s1, v0.s[1]
	fadd  s2, s2, s3
	ret
```
```nasm
Vector3Add(Vector3, Vector3):
	fadd  s0, s0, s3
	fadd  s1, s1, s4
	fadd  s2, s2, s5
	ret
```
Quite nice, isn't it?

## Visibility

I believe code should not hide things from the developer. Code should be very explicit and show exactly what it does because it can avoid bugs. References tend to hide something huge about the data being shared with the function: **mutability**. Let's take a function that normalizes the vector and mutates the values (usually, in this case, I would stick with a pure function, without mutations, that returns a Vector3 with the new values, avoiding side effects. This is only for educational purposes):
```cpp
void Vector3Normalize(Vector3 &vector) {
	vector /= vector.length();
}
```
To call this function we would do something like this:
```cpp
Vector3 vector = { 5.0, 3.2, 0.0 };

void Update() {
	...
	Vector3Normalize(vector);
	...
}
```
This has a problem with visibility. The code for a function that mutates a variable is **exactly the same** as a function that does not mutate anything. In a large codebase, where you have to several calls to different functions and is impossible to keep track of all the state changes in your head, this can be a large source of bugs because you don't know which function does what, when the variable was changed, who changed it. It quickly can become a mess.

But... If instead of using a reference, that hides the behavior, and use a pointer, we get the following:
```cpp
void Vector3Normalize(Vector3 *vector) {
	*vector /= vector->length();
}

Vector3 vector = { 5.0, 3.2, 0.0 };

void Update() {
	...
	Vector3Normalize(&vector);
	...
}
```
Now it is much more visible. I know that this function accepts a pointer and will most likely mutate the state. I can avoid a whole sort of headaches by just having the behavior explicit.

The Rust programming language takes a step further and forces the programmer to be very expressive with mutability and sharing references. For example, let's code the same example of Vector3 in Rust:
```rust
struct Vector3 {
	f32 x,
	f32 y,
	f32 z,
}

fn vector3_normalize(vector: &mut Vector3) {
	vector /= vector.length();
}

fn update() {
	let mut vector = Vector3 { x: 5.0, y: 3.2, z: 0.0 };
	...
	vector3_normalize(&mut vector);
}
```
You can see that Rust forces us to be very expressive, even redundant. At the moment of declaration of the variable ```vector```, I **have** to explicitly use the keyword ```mut``` to allow the state of it to be mutable and also when I pass a reference of the variable to a function, using ```&mut vector```. If those conditions aren't met, the compiler will give an error message. Everything has to be **very explicit**, something you don't get with C++'s references.

## Final thoughts

I hope with these examples it becomes clear why references tend not to be a good idea. These are just some of the many weirdnesses of C++ that I try to avoid. Generally, simple things are better. C++ will try to overcomplicate things when a simple C style will be more readable, more performant both for compile time and execution time, and easier to debug and maintain. If you want more thoughts about this topic and why the C++ way of thinking tends to be bad, you can check out this [incredible (and quite polemic) talk](https://www.youtube.com/watch?v=rX0ItVEVjHc) by Mike Acton at CppCon 2014.
